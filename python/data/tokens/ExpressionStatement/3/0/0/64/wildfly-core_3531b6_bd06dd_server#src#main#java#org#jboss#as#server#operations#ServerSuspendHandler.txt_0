UPD ExpressionStatement@@MethodInvocation:context.addStep(new OperationStepHandler(){
  @Override public void execute(  final OperationContext context,  ModelNode operation) throws OperationFailedException {
    final ServiceRegistry registry=context.getServiceRegistry(false);
    ServiceController<SuspendController> suspendControllerServiceController=(ServiceController<SuspendController>)registry.getRequiredService(SuspendController.SERVICE_NAME);
    final SuspendController suspendController=suspendControllerServiceController.getValue();
    OperationListener operationListener=new OperationListener(){
      @Override public void suspendStarted(){
      }
      @Override public void complete(){
        suspendController.removeListener(this);
        context.completeStep(new RollbackHandler(suspendController));
      }
      @Override public void cancelled(){
        suspendController.removeListener(this);
        context.setRollbackOnly();
        context.completeStep(new RollbackHandler(suspendController));
      }
      @Override public void timeout(){
        suspendController.removeListener(this);
        context.completeStep(new RollbackHandler(suspendController));
      }
    }
;
    suspendController.addListener(operationListener);
    suspendController.suspend(timeout > 0 ? timeout * 1000 : timeout);
  }
}
,OperationContext.Stage.RUNTIME) @TO@ MethodInvocation:context.addStep(new OperationStepHandler(){
  @Override public void execute(  final OperationContext context,  ModelNode operation) throws OperationFailedException {
    final ServiceRegistry registry=context.getServiceRegistry(false);
    ServiceController<SuspendController> suspendControllerServiceController=(ServiceController<SuspendController>)registry.getRequiredService(SuspendController.SERVICE_NAME);
    final SuspendController suspendController=suspendControllerServiceController.getValue();
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicBoolean cancelled=new AtomicBoolean();
    OperationListener operationListener=new OperationListener(){
      @Override public void suspendStarted(){
      }
      @Override public void complete(){
        suspendController.removeListener(this);
        latch.countDown();
      }
      @Override public void cancelled(){
        suspendController.removeListener(this);
        cancelled.set(true);
        latch.countDown();
      }
      @Override public void timeout(){
        suspendController.removeListener(this);
        latch.countDown();
      }
    }
;
    suspendController.addListener(operationListener);
    suspendController.suspend(timeout > 0 ? timeout * 1000 : timeout);
    if (timeout != 0) {
      try {
        latch.await();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
    if (cancelled.get()) {
      context.setRollbackOnly();
    }
    context.completeStep(new RollbackHandler(suspendController));
  }
}
,OperationContext.Stage.RUNTIME) @AT@ 3985 @LENGTH@ 1772
---UPD MethodInvocation@@context.addStep(new OperationStepHandler(){
  @Override public void execute(  final OperationContext context,  ModelNode operation) throws OperationFailedException {
    final ServiceRegistry registry=context.getServiceRegistry(false);
    ServiceController<SuspendController> suspendControllerServiceController=(ServiceController<SuspendController>)registry.getRequiredService(SuspendController.SERVICE_NAME);
    final SuspendController suspendController=suspendControllerServiceController.getValue();
    OperationListener operationListener=new OperationListener(){
      @Override public void suspendStarted(){
      }
      @Override public void complete(){
        suspendController.removeListener(this);
        context.completeStep(new RollbackHandler(suspendController));
      }
      @Override public void cancelled(){
        suspendController.removeListener(this);
        context.setRollbackOnly();
        context.completeStep(new RollbackHandler(suspendController));
      }
      @Override public void timeout(){
        suspendController.removeListener(this);
        context.completeStep(new RollbackHandler(suspendController));
      }
    }
;
    suspendController.addListener(operationListener);
    suspendController.suspend(timeout > 0 ? timeout * 1000 : timeout);
  }
}
,OperationContext.Stage.RUNTIME) @TO@ context.addStep(new OperationStepHandler(){
  @Override public void execute(  final OperationContext context,  ModelNode operation) throws OperationFailedException {
    final ServiceRegistry registry=context.getServiceRegistry(false);
    ServiceController<SuspendController> suspendControllerServiceController=(ServiceController<SuspendController>)registry.getRequiredService(SuspendController.SERVICE_NAME);
    final SuspendController suspendController=suspendControllerServiceController.getValue();
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicBoolean cancelled=new AtomicBoolean();
    OperationListener operationListener=new OperationListener(){
      @Override public void suspendStarted(){
      }
      @Override public void complete(){
        suspendController.removeListener(this);
        latch.countDown();
      }
      @Override public void cancelled(){
        suspendController.removeListener(this);
        cancelled.set(true);
        latch.countDown();
      }
      @Override public void timeout(){
        suspendController.removeListener(this);
        latch.countDown();
      }
    }
;
    suspendController.addListener(operationListener);
    suspendController.suspend(timeout > 0 ? timeout * 1000 : timeout);
    if (timeout != 0) {
      try {
        latch.await();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
    if (cancelled.get()) {
      context.setRollbackOnly();
    }
    context.completeStep(new RollbackHandler(suspendController));
  }
}
,OperationContext.Stage.RUNTIME) @AT@ 3985 @LENGTH@ 1771
------UPD SimpleName@@MethodName:addStep:[new OperationStepHandler(){
  @Override public void execute(  final OperationContext context,  ModelNode operation) throws OperationFailedException {
    final ServiceRegistry registry=context.getServiceRegistry(false);
    ServiceController<SuspendController> suspendControllerServiceController=(ServiceController<SuspendController>)registry.getRequiredService(SuspendController.SERVICE_NAME);
    final SuspendController suspendController=suspendControllerServiceController.getValue();
    OperationListener operationListener=new OperationListener(){
      @Override public void suspendStarted(){
      }
      @Override public void complete(){
        suspendController.removeListener(this);
        context.completeStep(new RollbackHandler(suspendController));
      }
      @Override public void cancelled(){
        suspendController.removeListener(this);
        context.setRollbackOnly();
        context.completeStep(new RollbackHandler(suspendController));
      }
      @Override public void timeout(){
        suspendController.removeListener(this);
        context.completeStep(new RollbackHandler(suspendController));
      }
    }
;
    suspendController.addListener(operationListener);
    suspendController.suspend(timeout > 0 ? timeout * 1000 : timeout);
  }
}
, OperationContext.Stage.RUNTIME] @TO@ MethodName:addStep:[new OperationStepHandler(){
  @Override public void execute(  final OperationContext context,  ModelNode operation) throws OperationFailedException {
    final ServiceRegistry registry=context.getServiceRegistry(false);
    ServiceController<SuspendController> suspendControllerServiceController=(ServiceController<SuspendController>)registry.getRequiredService(SuspendController.SERVICE_NAME);
    final SuspendController suspendController=suspendControllerServiceController.getValue();
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicBoolean cancelled=new AtomicBoolean();
    OperationListener operationListener=new OperationListener(){
      @Override public void suspendStarted(){
      }
      @Override public void complete(){
        suspendController.removeListener(this);
        latch.countDown();
      }
      @Override public void cancelled(){
        suspendController.removeListener(this);
        cancelled.set(true);
        latch.countDown();
      }
      @Override public void timeout(){
        suspendController.removeListener(this);
        latch.countDown();
      }
    }
;
    suspendController.addListener(operationListener);
    suspendController.suspend(timeout > 0 ? timeout * 1000 : timeout);
    if (timeout != 0) {
      try {
        latch.await();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
    if (cancelled.get()) {
      context.setRollbackOnly();
    }
    context.completeStep(new RollbackHandler(suspendController));
  }
}
, OperationContext.Stage.RUNTIME] @AT@ 3993 @LENGTH@ 1763

