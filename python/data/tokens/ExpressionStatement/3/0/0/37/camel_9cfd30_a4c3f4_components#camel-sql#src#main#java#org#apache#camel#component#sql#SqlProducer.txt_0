UPD ExpressionStatement@@MethodInvocation:jdbcTemplate.execute(preparedQuery,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      boolean isResultSet=ps.execute();
      if (isResultSet) {
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<Map<String,Object>> data=getEndpoint().queryForList(ps.getResultSet());
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(ps.getResultSet());
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    return null;
  }
}
) @TO@ MethodInvocation:jdbcTemplate.execute(preparedQuery,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      boolean isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<Map<String,Object>> data=getEndpoint().queryForList(ps.getResultSet());
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(ps.getResultSet());
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    return null;
  }
}
) @AT@ 2456 @LENGTH@ 4125
---UPD MethodInvocation@@jdbcTemplate.execute(preparedQuery,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      boolean isResultSet=ps.execute();
      if (isResultSet) {
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<Map<String,Object>> data=getEndpoint().queryForList(ps.getResultSet());
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(ps.getResultSet());
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    return null;
  }
}
) @TO@ jdbcTemplate.execute(preparedQuery,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      boolean isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<Map<String,Object>> data=getEndpoint().queryForList(ps.getResultSet());
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(ps.getResultSet());
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    return null;
  }
}
) @AT@ 2456 @LENGTH@ 4124
------UPD SimpleName@@MethodName:execute:[preparedQuery, new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      boolean isResultSet=ps.execute();
      if (isResultSet) {
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<Map<String,Object>> data=getEndpoint().queryForList(ps.getResultSet());
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(ps.getResultSet());
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    return null;
  }
}
] @TO@ MethodName:execute:[preparedQuery, new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      boolean isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<Map<String,Object>> data=getEndpoint().queryForList(ps.getResultSet());
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(ps.getResultSet());
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    return null;
  }
}
] @AT@ 2469 @LENGTH@ 4111

