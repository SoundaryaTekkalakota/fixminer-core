UPD ExpressionStatement@@MethodInvocation:jdbcTemplate.execute(statementCreator,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    boolean isResultSet=false;
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<?> data=getEndpoint().queryForList(rs,true);
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else           if (getEndpoint().getOutputHeader() != null) {
            exchange.getOut().setBody(exchange.getIn().getBody());
            exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(rs);
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else             if (getEndpoint().getOutputHeader() != null) {
              exchange.getOut().setBody(exchange.getIn().getBody());
              exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    if (shouldRetrieveGeneratedKeys) {
      if (isResultSet) {
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,Collections.EMPTY_LIST);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,0);
      }
 else {
        List<?> generatedKeys=getEndpoint().queryForList(ps.getGeneratedKeys(),false);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,generatedKeys);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,generatedKeys.size());
      }
    }
    return null;
  }
}
) @TO@ MethodInvocation:jdbcTemplate.execute(statementCreator,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    boolean isResultSet=false;
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<?> data=getEndpoint().queryForList(rs,true);
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else           if (getEndpoint().getOutputHeader() != null) {
            exchange.getOut().setBody(exchange.getIn().getBody());
            exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(rs);
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else             if (getEndpoint().getOutputHeader() != null) {
              exchange.getOut().setBody(exchange.getIn().getBody());
              exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    if (shouldRetrieveGeneratedKeys) {
      if (!exchange.hasOut()) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      }
      if (isResultSet) {
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,Collections.EMPTY_LIST);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,0);
      }
 else {
        List<?> generatedKeys=getEndpoint().queryForList(ps.getGeneratedKeys(),false);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,generatedKeys);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,generatedKeys.size());
      }
    }
    return null;
  }
}
) @AT@ 4170 @LENGTH@ 5509
---UPD MethodInvocation@@jdbcTemplate.execute(statementCreator,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    boolean isResultSet=false;
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<?> data=getEndpoint().queryForList(rs,true);
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else           if (getEndpoint().getOutputHeader() != null) {
            exchange.getOut().setBody(exchange.getIn().getBody());
            exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(rs);
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else             if (getEndpoint().getOutputHeader() != null) {
              exchange.getOut().setBody(exchange.getIn().getBody());
              exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    if (shouldRetrieveGeneratedKeys) {
      if (isResultSet) {
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,Collections.EMPTY_LIST);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,0);
      }
 else {
        List<?> generatedKeys=getEndpoint().queryForList(ps.getGeneratedKeys(),false);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,generatedKeys);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,generatedKeys.size());
      }
    }
    return null;
  }
}
) @TO@ jdbcTemplate.execute(statementCreator,new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    boolean isResultSet=false;
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<?> data=getEndpoint().queryForList(rs,true);
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else           if (getEndpoint().getOutputHeader() != null) {
            exchange.getOut().setBody(exchange.getIn().getBody());
            exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(rs);
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else             if (getEndpoint().getOutputHeader() != null) {
              exchange.getOut().setBody(exchange.getIn().getBody());
              exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    if (shouldRetrieveGeneratedKeys) {
      if (!exchange.hasOut()) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      }
      if (isResultSet) {
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,Collections.EMPTY_LIST);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,0);
      }
 else {
        List<?> generatedKeys=getEndpoint().queryForList(ps.getGeneratedKeys(),false);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,generatedKeys);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,generatedKeys.size());
      }
    }
    return null;
  }
}
) @AT@ 4170 @LENGTH@ 5508
------UPD SimpleName@@MethodName:execute:[statementCreator, new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    boolean isResultSet=false;
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<?> data=getEndpoint().queryForList(rs,true);
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else           if (getEndpoint().getOutputHeader() != null) {
            exchange.getOut().setBody(exchange.getIn().getBody());
            exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(rs);
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else             if (getEndpoint().getOutputHeader() != null) {
              exchange.getOut().setBody(exchange.getIn().getBody());
              exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    if (shouldRetrieveGeneratedKeys) {
      if (isResultSet) {
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,Collections.EMPTY_LIST);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,0);
      }
 else {
        List<?> generatedKeys=getEndpoint().queryForList(ps.getGeneratedKeys(),false);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,generatedKeys);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,generatedKeys.size());
      }
    }
    return null;
  }
}
] @TO@ MethodName:execute:[statementCreator, new PreparedStatementCallback<Map<?,?>>(){
  public Map<?,?> doInPreparedStatement(  PreparedStatement ps) throws SQLException {
    int expected=parametersCount > 0 ? parametersCount : ps.getParameterMetaData().getParameterCount();
    if (alwaysPopulateStatement || expected > 0) {
      if (batch) {
        Iterator<?> iterator=exchange.getIn().getBody(Iterator.class);
        while (iterator != null && iterator.hasNext()) {
          Object value=iterator.next();
          Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,value);
          sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
          ps.addBatch();
        }
      }
 else {
        Iterator<?> i=sqlPrepareStatementStrategy.createPopulateIterator(sql,preparedQuery,expected,exchange,exchange.getIn().getBody());
        sqlPrepareStatementStrategy.populateStatement(ps,i,expected);
      }
    }
    boolean isResultSet=false;
    if (batch) {
      int[] updateCounts=ps.executeBatch();
      int total=0;
      for (      int count : updateCounts) {
        total+=count;
      }
      exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,total);
    }
 else {
      isResultSet=ps.execute();
      if (isResultSet) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        ResultSet rs=ps.getResultSet();
        SqlOutputType outputType=getEndpoint().getOutputType();
        log.trace("Got result list from query: {}, outputType={}",rs,outputType);
        if (outputType == SqlOutputType.SelectList) {
          List<?> data=getEndpoint().queryForList(rs,true);
          if (getEndpoint().isNoop()) {
            exchange.getOut().setBody(exchange.getIn().getBody());
          }
 else           if (getEndpoint().getOutputHeader() != null) {
            exchange.getOut().setBody(exchange.getIn().getBody());
            exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
          }
 else {
            exchange.getOut().setBody(data);
          }
          exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,data.size());
        }
 else         if (outputType == SqlOutputType.SelectOne) {
          Object data=getEndpoint().queryForObject(rs);
          if (data != null) {
            if (getEndpoint().isNoop()) {
              exchange.getOut().setBody(exchange.getIn().getBody());
            }
 else             if (getEndpoint().getOutputHeader() != null) {
              exchange.getOut().setBody(exchange.getIn().getBody());
              exchange.getOut().setHeader(getEndpoint().getOutputHeader(),data);
            }
 else {
              exchange.getOut().setBody(data);
            }
            exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT,1);
          }
        }
 else {
          throw new IllegalArgumentException("Invalid outputType=" + outputType);
        }
      }
 else {
        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT,ps.getUpdateCount());
      }
    }
    if (shouldRetrieveGeneratedKeys) {
      if (!exchange.hasOut()) {
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      }
      if (isResultSet) {
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,Collections.EMPTY_LIST);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,0);
      }
 else {
        List<?> generatedKeys=getEndpoint().queryForList(ps.getGeneratedKeys(),false);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA,generatedKeys);
        exchange.getOut().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT,generatedKeys.size());
      }
    }
    return null;
  }
}
] @AT@ 4183 @LENGTH@ 5495

