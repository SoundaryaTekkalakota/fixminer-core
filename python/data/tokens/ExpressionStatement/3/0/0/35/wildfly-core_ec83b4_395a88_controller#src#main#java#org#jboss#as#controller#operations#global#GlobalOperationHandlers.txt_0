UPD ExpressionStatement@@MethodInvocation:context.addStep(resultItem,remoteOp,new OperationStepHandler(){
  @Override public void execute(  OperationContext context,  ModelNode operation) throws OperationFailedException {
    try {
      ControllerLogger.MGMT_OP_LOGGER.tracef("sending ModelAddressResolver request %s to remote process using %s",operation,proxyHandler);
      final AtomicBoolean filtered=new AtomicBoolean(false);
      context.addStep(new FilterableRemoteOperationStepHandler(proxyHandler,base,filtered,filteredData,ignoreMissing),OperationContext.Stage.MODEL,true);
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
          if (filtered.get()) {
            ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
            return;
          }
          PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
          if (remaining.isMultiTarget()) {
            if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
              for (              final ModelNode rr : resultItem.get(RESULT).asList()) {
                final ModelNode nr=result.add();
                final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
                int max=Math.min(base.size(),address.size());
                int match=0;
                for (int i=0; i < max; i++) {
                  final PathElement eb=base.getElement(i);
                  final PathElement ea=address.getElement(i);
                  if (eb.getKey().equals(ea.getKey())) {
                    match=i + 1;
                  }
                }
                final PathAddress resolvedAddress=base.append(address.subAddress(match));
                ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
                nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
                nr.get(OUTCOME).set(rr.get(OUTCOME));
                nr.get(RESULT).set(rr.get(RESULT));
                if (rr.hasDefined(RESPONSE_HEADERS)) {
                  ModelNode headers=rr.get(RESPONSE_HEADERS);
                  ModelNode acc=headers.remove(ACCESS_CONTROL);
                  if (headers.asInt() > 0) {
                    nr.get(RESPONSE_HEADERS).set(headers);
                  }
                  if (acc.isDefined()) {
                    filteredData.populate(acc,rbacPrefix);
                    ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
                  }
                }
              }
              if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
                ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
              }
            }
          }
 else {
            ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
            final ModelNode nr=result.add();
            nr.get(OP_ADDR).set(fullAddress.toModelNode());
            nr.get(OUTCOME).set(resultItem.get(OUTCOME));
            nr.get(RESULT).set(resultItem.get(RESULT));
            if (resultItem.hasDefined(RESPONSE_HEADERS)) {
              ModelNode headers=resultItem.get(RESPONSE_HEADERS);
              ModelNode acc=headers.remove(ACCESS_CONTROL);
              if (headers.asInt() > 0) {
                nr.get(RESPONSE_HEADERS).set(headers);
              }
              if (acc.isDefined()) {
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
                ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
              }
            }
          }
        }
      }
);
    }
 catch (    Resource.NoSuchResourceException e) {
    }
  }
}
,OperationContext.Stage.MODEL,true) @TO@ MethodInvocation:context.addStep(resultItem,remoteOp,new OperationStepHandler(){
  @Override public void execute(  OperationContext context,  ModelNode operation) throws OperationFailedException {
    try {
      ControllerLogger.MGMT_OP_LOGGER.tracef("sending ModelAddressResolver request %s to remote process using %s",operation,proxyHandler);
      final AtomicBoolean filtered=new AtomicBoolean(false);
      context.addStep(new FilterableRemoteOperationStepHandler(proxyHandler,base,filtered,filteredData,ignoreMissing),OperationContext.Stage.MODEL,true);
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
          if (filtered.get()) {
            ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
            return;
          }
          PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
          if (remaining.isMultiTarget()) {
            if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
              for (              final ModelNode rr : resultItem.get(RESULT).asList()) {
                final ModelNode nr=result.add();
                final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
                int max=Math.min(base.size(),address.size());
                int match=0;
                for (int i=0; i < max; i++) {
                  final PathElement eb=base.getElement(i);
                  final PathElement ea=address.getElement(i);
                  if (eb.getKey().equals(ea.getKey())) {
                    match=i + 1;
                  }
                }
                final PathAddress resolvedAddress=base.append(address.subAddress(match));
                ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
                nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
                nr.get(OUTCOME).set(rr.get(OUTCOME));
                nr.get(RESULT).set(rr.get(RESULT));
                if (rr.hasDefined(RESPONSE_HEADERS)) {
                  ModelNode headers=rr.get(RESPONSE_HEADERS);
                  ModelNode acc=headers.remove(ACCESS_CONTROL);
                  if (headers.asInt() > 0) {
                    nr.get(RESPONSE_HEADERS).set(headers);
                  }
                  if (acc != null && acc.isDefined()) {
                    filteredData.populate(acc,rbacPrefix);
                    ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
                  }
                }
              }
              if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
                ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
              }
            }
          }
 else {
            ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
            final ModelNode nr=result.add();
            nr.get(OP_ADDR).set(fullAddress.toModelNode());
            nr.get(OUTCOME).set(resultItem.get(OUTCOME));
            nr.get(RESULT).set(resultItem.get(RESULT));
            if (resultItem.hasDefined(RESPONSE_HEADERS)) {
              ModelNode headers=resultItem.get(RESPONSE_HEADERS);
              ModelNode acc=headers.remove(ACCESS_CONTROL);
              if (headers.asInt() > 0) {
                nr.get(RESPONSE_HEADERS).set(headers);
              }
              if (acc != null && acc.isDefined()) {
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
                ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
              }
            }
          }
        }
      }
);
    }
 catch (    Resource.NoSuchResourceException e) {
    }
  }
}
,OperationContext.Stage.MODEL,true) @AT@ 37754 @LENGTH@ 7282
---UPD MethodInvocation@@context.addStep(resultItem,remoteOp,new OperationStepHandler(){
  @Override public void execute(  OperationContext context,  ModelNode operation) throws OperationFailedException {
    try {
      ControllerLogger.MGMT_OP_LOGGER.tracef("sending ModelAddressResolver request %s to remote process using %s",operation,proxyHandler);
      final AtomicBoolean filtered=new AtomicBoolean(false);
      context.addStep(new FilterableRemoteOperationStepHandler(proxyHandler,base,filtered,filteredData,ignoreMissing),OperationContext.Stage.MODEL,true);
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
          if (filtered.get()) {
            ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
            return;
          }
          PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
          if (remaining.isMultiTarget()) {
            if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
              for (              final ModelNode rr : resultItem.get(RESULT).asList()) {
                final ModelNode nr=result.add();
                final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
                int max=Math.min(base.size(),address.size());
                int match=0;
                for (int i=0; i < max; i++) {
                  final PathElement eb=base.getElement(i);
                  final PathElement ea=address.getElement(i);
                  if (eb.getKey().equals(ea.getKey())) {
                    match=i + 1;
                  }
                }
                final PathAddress resolvedAddress=base.append(address.subAddress(match));
                ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
                nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
                nr.get(OUTCOME).set(rr.get(OUTCOME));
                nr.get(RESULT).set(rr.get(RESULT));
                if (rr.hasDefined(RESPONSE_HEADERS)) {
                  ModelNode headers=rr.get(RESPONSE_HEADERS);
                  ModelNode acc=headers.remove(ACCESS_CONTROL);
                  if (headers.asInt() > 0) {
                    nr.get(RESPONSE_HEADERS).set(headers);
                  }
                  if (acc.isDefined()) {
                    filteredData.populate(acc,rbacPrefix);
                    ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
                  }
                }
              }
              if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
                ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
              }
            }
          }
 else {
            ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
            final ModelNode nr=result.add();
            nr.get(OP_ADDR).set(fullAddress.toModelNode());
            nr.get(OUTCOME).set(resultItem.get(OUTCOME));
            nr.get(RESULT).set(resultItem.get(RESULT));
            if (resultItem.hasDefined(RESPONSE_HEADERS)) {
              ModelNode headers=resultItem.get(RESPONSE_HEADERS);
              ModelNode acc=headers.remove(ACCESS_CONTROL);
              if (headers.asInt() > 0) {
                nr.get(RESPONSE_HEADERS).set(headers);
              }
              if (acc.isDefined()) {
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
                ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
              }
            }
          }
        }
      }
);
    }
 catch (    Resource.NoSuchResourceException e) {
    }
  }
}
,OperationContext.Stage.MODEL,true) @TO@ context.addStep(resultItem,remoteOp,new OperationStepHandler(){
  @Override public void execute(  OperationContext context,  ModelNode operation) throws OperationFailedException {
    try {
      ControllerLogger.MGMT_OP_LOGGER.tracef("sending ModelAddressResolver request %s to remote process using %s",operation,proxyHandler);
      final AtomicBoolean filtered=new AtomicBoolean(false);
      context.addStep(new FilterableRemoteOperationStepHandler(proxyHandler,base,filtered,filteredData,ignoreMissing),OperationContext.Stage.MODEL,true);
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
          if (filtered.get()) {
            ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
            return;
          }
          PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
          if (remaining.isMultiTarget()) {
            if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
              for (              final ModelNode rr : resultItem.get(RESULT).asList()) {
                final ModelNode nr=result.add();
                final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
                int max=Math.min(base.size(),address.size());
                int match=0;
                for (int i=0; i < max; i++) {
                  final PathElement eb=base.getElement(i);
                  final PathElement ea=address.getElement(i);
                  if (eb.getKey().equals(ea.getKey())) {
                    match=i + 1;
                  }
                }
                final PathAddress resolvedAddress=base.append(address.subAddress(match));
                ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
                nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
                nr.get(OUTCOME).set(rr.get(OUTCOME));
                nr.get(RESULT).set(rr.get(RESULT));
                if (rr.hasDefined(RESPONSE_HEADERS)) {
                  ModelNode headers=rr.get(RESPONSE_HEADERS);
                  ModelNode acc=headers.remove(ACCESS_CONTROL);
                  if (headers.asInt() > 0) {
                    nr.get(RESPONSE_HEADERS).set(headers);
                  }
                  if (acc != null && acc.isDefined()) {
                    filteredData.populate(acc,rbacPrefix);
                    ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
                  }
                }
              }
              if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
                ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
              }
            }
          }
 else {
            ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
            final ModelNode nr=result.add();
            nr.get(OP_ADDR).set(fullAddress.toModelNode());
            nr.get(OUTCOME).set(resultItem.get(OUTCOME));
            nr.get(RESULT).set(resultItem.get(RESULT));
            if (resultItem.hasDefined(RESPONSE_HEADERS)) {
              ModelNode headers=resultItem.get(RESPONSE_HEADERS);
              ModelNode acc=headers.remove(ACCESS_CONTROL);
              if (headers.asInt() > 0) {
                nr.get(RESPONSE_HEADERS).set(headers);
              }
              if (acc != null && acc.isDefined()) {
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
                ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
              }
            }
          }
        }
      }
);
    }
 catch (    Resource.NoSuchResourceException e) {
    }
  }
}
,OperationContext.Stage.MODEL,true) @AT@ 37754 @LENGTH@ 7281
------UPD SimpleName@@MethodName:addStep:[resultItem, remoteOp, new OperationStepHandler(){
  @Override public void execute(  OperationContext context,  ModelNode operation) throws OperationFailedException {
    try {
      ControllerLogger.MGMT_OP_LOGGER.tracef("sending ModelAddressResolver request %s to remote process using %s",operation,proxyHandler);
      final AtomicBoolean filtered=new AtomicBoolean(false);
      context.addStep(new FilterableRemoteOperationStepHandler(proxyHandler,base,filtered,filteredData,ignoreMissing),OperationContext.Stage.MODEL,true);
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
          if (filtered.get()) {
            ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
            return;
          }
          PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
          if (remaining.isMultiTarget()) {
            if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
              for (              final ModelNode rr : resultItem.get(RESULT).asList()) {
                final ModelNode nr=result.add();
                final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
                int max=Math.min(base.size(),address.size());
                int match=0;
                for (int i=0; i < max; i++) {
                  final PathElement eb=base.getElement(i);
                  final PathElement ea=address.getElement(i);
                  if (eb.getKey().equals(ea.getKey())) {
                    match=i + 1;
                  }
                }
                final PathAddress resolvedAddress=base.append(address.subAddress(match));
                ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
                nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
                nr.get(OUTCOME).set(rr.get(OUTCOME));
                nr.get(RESULT).set(rr.get(RESULT));
                if (rr.hasDefined(RESPONSE_HEADERS)) {
                  ModelNode headers=rr.get(RESPONSE_HEADERS);
                  ModelNode acc=headers.remove(ACCESS_CONTROL);
                  if (headers.asInt() > 0) {
                    nr.get(RESPONSE_HEADERS).set(headers);
                  }
                  if (acc.isDefined()) {
                    filteredData.populate(acc,rbacPrefix);
                    ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
                  }
                }
              }
              if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
                ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
              }
            }
          }
 else {
            ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
            final ModelNode nr=result.add();
            nr.get(OP_ADDR).set(fullAddress.toModelNode());
            nr.get(OUTCOME).set(resultItem.get(OUTCOME));
            nr.get(RESULT).set(resultItem.get(RESULT));
            if (resultItem.hasDefined(RESPONSE_HEADERS)) {
              ModelNode headers=resultItem.get(RESPONSE_HEADERS);
              ModelNode acc=headers.remove(ACCESS_CONTROL);
              if (headers.asInt() > 0) {
                nr.get(RESPONSE_HEADERS).set(headers);
              }
              if (acc.isDefined()) {
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
                ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
              }
            }
          }
        }
      }
);
    }
 catch (    Resource.NoSuchResourceException e) {
    }
  }
}
, OperationContext.Stage.MODEL, true] @TO@ MethodName:addStep:[resultItem, remoteOp, new OperationStepHandler(){
  @Override public void execute(  OperationContext context,  ModelNode operation) throws OperationFailedException {
    try {
      ControllerLogger.MGMT_OP_LOGGER.tracef("sending ModelAddressResolver request %s to remote process using %s",operation,proxyHandler);
      final AtomicBoolean filtered=new AtomicBoolean(false);
      context.addStep(new FilterableRemoteOperationStepHandler(proxyHandler,base,filtered,filteredData,ignoreMissing),OperationContext.Stage.MODEL,true);
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
          if (filtered.get()) {
            ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
            return;
          }
          PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
          if (remaining.isMultiTarget()) {
            if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
              for (              final ModelNode rr : resultItem.get(RESULT).asList()) {
                final ModelNode nr=result.add();
                final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
                int max=Math.min(base.size(),address.size());
                int match=0;
                for (int i=0; i < max; i++) {
                  final PathElement eb=base.getElement(i);
                  final PathElement ea=address.getElement(i);
                  if (eb.getKey().equals(ea.getKey())) {
                    match=i + 1;
                  }
                }
                final PathAddress resolvedAddress=base.append(address.subAddress(match));
                ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
                nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
                nr.get(OUTCOME).set(rr.get(OUTCOME));
                nr.get(RESULT).set(rr.get(RESULT));
                if (rr.hasDefined(RESPONSE_HEADERS)) {
                  ModelNode headers=rr.get(RESPONSE_HEADERS);
                  ModelNode acc=headers.remove(ACCESS_CONTROL);
                  if (headers.asInt() > 0) {
                    nr.get(RESPONSE_HEADERS).set(headers);
                  }
                  if (acc != null && acc.isDefined()) {
                    filteredData.populate(acc,rbacPrefix);
                    ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
                  }
                }
              }
              if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
                ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
              }
            }
          }
 else {
            ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
            final ModelNode nr=result.add();
            nr.get(OP_ADDR).set(fullAddress.toModelNode());
            nr.get(OUTCOME).set(resultItem.get(OUTCOME));
            nr.get(RESULT).set(resultItem.get(RESULT));
            if (resultItem.hasDefined(RESPONSE_HEADERS)) {
              ModelNode headers=resultItem.get(RESPONSE_HEADERS);
              ModelNode acc=headers.remove(ACCESS_CONTROL);
              if (headers.asInt() > 0) {
                nr.get(RESPONSE_HEADERS).set(headers);
              }
              if (acc != null && acc.isDefined()) {
                filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
                ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
              }
            }
          }
        }
      }
);
    }
 catch (    Resource.NoSuchResourceException e) {
    }
  }
}
, OperationContext.Stage.MODEL, true] @AT@ 37762 @LENGTH@ 7273

