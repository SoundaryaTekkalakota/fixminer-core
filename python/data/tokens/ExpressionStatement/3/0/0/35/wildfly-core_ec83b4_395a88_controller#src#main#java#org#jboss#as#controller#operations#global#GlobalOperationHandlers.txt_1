UPD ExpressionStatement@@MethodInvocation:context.completeStep(new OperationContext.ResultHandler(){
  @Override public void handleResult(  OperationContext.ResultAction resultAction,  OperationContext context,  ModelNode operation){
    ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
    if (filtered.get()) {
      ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
      return;
    }
    PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
    if (remaining.isMultiTarget()) {
      if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
        for (        final ModelNode rr : resultItem.get(RESULT).asList()) {
          final ModelNode nr=result.add();
          final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
          int max=Math.min(base.size(),address.size());
          int match=0;
          for (int i=0; i < max; i++) {
            final PathElement eb=base.getElement(i);
            final PathElement ea=address.getElement(i);
            if (eb.getKey().equals(ea.getKey())) {
              match=i + 1;
            }
          }
          final PathAddress resolvedAddress=base.append(address.subAddress(match));
          ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
          nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
          nr.get(OUTCOME).set(rr.get(OUTCOME));
          nr.get(RESULT).set(rr.get(RESULT));
          if (rr.hasDefined(RESPONSE_HEADERS)) {
            ModelNode headers=rr.get(RESPONSE_HEADERS);
            ModelNode acc=headers.remove(ACCESS_CONTROL);
            if (headers.asInt() > 0) {
              nr.get(RESPONSE_HEADERS).set(headers);
            }
            if (acc.isDefined()) {
              filteredData.populate(acc,rbacPrefix);
              ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
            }
          }
        }
        if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
          ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
        }
      }
    }
 else {
      ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
      final ModelNode nr=result.add();
      nr.get(OP_ADDR).set(fullAddress.toModelNode());
      nr.get(OUTCOME).set(resultItem.get(OUTCOME));
      nr.get(RESULT).set(resultItem.get(RESULT));
      if (resultItem.hasDefined(RESPONSE_HEADERS)) {
        ModelNode headers=resultItem.get(RESPONSE_HEADERS);
        ModelNode acc=headers.remove(ACCESS_CONTROL);
        if (headers.asInt() > 0) {
          nr.get(RESPONSE_HEADERS).set(headers);
        }
        if (acc.isDefined()) {
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
          ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
        }
      }
    }
  }
}
) @TO@ MethodInvocation:context.completeStep(new OperationContext.ResultHandler(){
  @Override public void handleResult(  OperationContext.ResultAction resultAction,  OperationContext context,  ModelNode operation){
    ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
    if (filtered.get()) {
      ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
      return;
    }
    PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
    if (remaining.isMultiTarget()) {
      if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
        for (        final ModelNode rr : resultItem.get(RESULT).asList()) {
          final ModelNode nr=result.add();
          final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
          int max=Math.min(base.size(),address.size());
          int match=0;
          for (int i=0; i < max; i++) {
            final PathElement eb=base.getElement(i);
            final PathElement ea=address.getElement(i);
            if (eb.getKey().equals(ea.getKey())) {
              match=i + 1;
            }
          }
          final PathAddress resolvedAddress=base.append(address.subAddress(match));
          ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
          nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
          nr.get(OUTCOME).set(rr.get(OUTCOME));
          nr.get(RESULT).set(rr.get(RESULT));
          if (rr.hasDefined(RESPONSE_HEADERS)) {
            ModelNode headers=rr.get(RESPONSE_HEADERS);
            ModelNode acc=headers.remove(ACCESS_CONTROL);
            if (headers.asInt() > 0) {
              nr.get(RESPONSE_HEADERS).set(headers);
            }
            if (acc != null && acc.isDefined()) {
              filteredData.populate(acc,rbacPrefix);
              ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
            }
          }
        }
        if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
          ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
        }
      }
    }
 else {
      ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
      final ModelNode nr=result.add();
      nr.get(OP_ADDR).set(fullAddress.toModelNode());
      nr.get(OUTCOME).set(resultItem.get(OUTCOME));
      nr.get(RESULT).set(resultItem.get(RESULT));
      if (resultItem.hasDefined(RESPONSE_HEADERS)) {
        ModelNode headers=resultItem.get(RESPONSE_HEADERS);
        ModelNode acc=headers.remove(ACCESS_CONTROL);
        if (headers.asInt() > 0) {
          nr.get(RESPONSE_HEADERS).set(headers);
        }
        if (acc != null && acc.isDefined()) {
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
          ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
        }
      }
    }
  }
}
) @AT@ 38632 @LENGTH@ 6152
---UPD MethodInvocation@@context.completeStep(new OperationContext.ResultHandler(){
  @Override public void handleResult(  OperationContext.ResultAction resultAction,  OperationContext context,  ModelNode operation){
    ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
    if (filtered.get()) {
      ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
      return;
    }
    PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
    if (remaining.isMultiTarget()) {
      if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
        for (        final ModelNode rr : resultItem.get(RESULT).asList()) {
          final ModelNode nr=result.add();
          final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
          int max=Math.min(base.size(),address.size());
          int match=0;
          for (int i=0; i < max; i++) {
            final PathElement eb=base.getElement(i);
            final PathElement ea=address.getElement(i);
            if (eb.getKey().equals(ea.getKey())) {
              match=i + 1;
            }
          }
          final PathAddress resolvedAddress=base.append(address.subAddress(match));
          ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
          nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
          nr.get(OUTCOME).set(rr.get(OUTCOME));
          nr.get(RESULT).set(rr.get(RESULT));
          if (rr.hasDefined(RESPONSE_HEADERS)) {
            ModelNode headers=rr.get(RESPONSE_HEADERS);
            ModelNode acc=headers.remove(ACCESS_CONTROL);
            if (headers.asInt() > 0) {
              nr.get(RESPONSE_HEADERS).set(headers);
            }
            if (acc.isDefined()) {
              filteredData.populate(acc,rbacPrefix);
              ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
            }
          }
        }
        if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
          ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
        }
      }
    }
 else {
      ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
      final ModelNode nr=result.add();
      nr.get(OP_ADDR).set(fullAddress.toModelNode());
      nr.get(OUTCOME).set(resultItem.get(OUTCOME));
      nr.get(RESULT).set(resultItem.get(RESULT));
      if (resultItem.hasDefined(RESPONSE_HEADERS)) {
        ModelNode headers=resultItem.get(RESPONSE_HEADERS);
        ModelNode acc=headers.remove(ACCESS_CONTROL);
        if (headers.asInt() > 0) {
          nr.get(RESPONSE_HEADERS).set(headers);
        }
        if (acc.isDefined()) {
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
          ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
        }
      }
    }
  }
}
) @TO@ context.completeStep(new OperationContext.ResultHandler(){
  @Override public void handleResult(  OperationContext.ResultAction resultAction,  OperationContext context,  ModelNode operation){
    ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
    if (filtered.get()) {
      ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
      return;
    }
    PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
    if (remaining.isMultiTarget()) {
      if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
        for (        final ModelNode rr : resultItem.get(RESULT).asList()) {
          final ModelNode nr=result.add();
          final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
          int max=Math.min(base.size(),address.size());
          int match=0;
          for (int i=0; i < max; i++) {
            final PathElement eb=base.getElement(i);
            final PathElement ea=address.getElement(i);
            if (eb.getKey().equals(ea.getKey())) {
              match=i + 1;
            }
          }
          final PathAddress resolvedAddress=base.append(address.subAddress(match));
          ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
          nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
          nr.get(OUTCOME).set(rr.get(OUTCOME));
          nr.get(RESULT).set(rr.get(RESULT));
          if (rr.hasDefined(RESPONSE_HEADERS)) {
            ModelNode headers=rr.get(RESPONSE_HEADERS);
            ModelNode acc=headers.remove(ACCESS_CONTROL);
            if (headers.asInt() > 0) {
              nr.get(RESPONSE_HEADERS).set(headers);
            }
            if (acc != null && acc.isDefined()) {
              filteredData.populate(acc,rbacPrefix);
              ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
            }
          }
        }
        if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
          ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
        }
      }
    }
 else {
      ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
      final ModelNode nr=result.add();
      nr.get(OP_ADDR).set(fullAddress.toModelNode());
      nr.get(OUTCOME).set(resultItem.get(OUTCOME));
      nr.get(RESULT).set(resultItem.get(RESULT));
      if (resultItem.hasDefined(RESPONSE_HEADERS)) {
        ModelNode headers=resultItem.get(RESPONSE_HEADERS);
        ModelNode acc=headers.remove(ACCESS_CONTROL);
        if (headers.asInt() > 0) {
          nr.get(RESPONSE_HEADERS).set(headers);
        }
        if (acc != null && acc.isDefined()) {
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
          ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
        }
      }
    }
  }
}
) @AT@ 38632 @LENGTH@ 6151
------UPD SimpleName@@MethodName:completeStep:[new OperationContext.ResultHandler(){
  @Override public void handleResult(  OperationContext.ResultAction resultAction,  OperationContext context,  ModelNode operation){
    ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
    if (filtered.get()) {
      ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
      return;
    }
    PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
    if (remaining.isMultiTarget()) {
      if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
        for (        final ModelNode rr : resultItem.get(RESULT).asList()) {
          final ModelNode nr=result.add();
          final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
          int max=Math.min(base.size(),address.size());
          int match=0;
          for (int i=0; i < max; i++) {
            final PathElement eb=base.getElement(i);
            final PathElement ea=address.getElement(i);
            if (eb.getKey().equals(ea.getKey())) {
              match=i + 1;
            }
          }
          final PathAddress resolvedAddress=base.append(address.subAddress(match));
          ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
          nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
          nr.get(OUTCOME).set(rr.get(OUTCOME));
          nr.get(RESULT).set(rr.get(RESULT));
          if (rr.hasDefined(RESPONSE_HEADERS)) {
            ModelNode headers=rr.get(RESPONSE_HEADERS);
            ModelNode acc=headers.remove(ACCESS_CONTROL);
            if (headers.asInt() > 0) {
              nr.get(RESPONSE_HEADERS).set(headers);
            }
            if (acc.isDefined()) {
              filteredData.populate(acc,rbacPrefix);
              ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
            }
          }
        }
        if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
          ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
        }
      }
    }
 else {
      ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
      final ModelNode nr=result.add();
      nr.get(OP_ADDR).set(fullAddress.toModelNode());
      nr.get(OUTCOME).set(resultItem.get(OUTCOME));
      nr.get(RESULT).set(resultItem.get(RESULT));
      if (resultItem.hasDefined(RESPONSE_HEADERS)) {
        ModelNode headers=resultItem.get(RESPONSE_HEADERS);
        ModelNode acc=headers.remove(ACCESS_CONTROL);
        if (headers.asInt() > 0) {
          nr.get(RESPONSE_HEADERS).set(headers);
        }
        if (acc.isDefined()) {
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
          ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
        }
      }
    }
  }
}
] @TO@ MethodName:completeStep:[new OperationContext.ResultHandler(){
  @Override public void handleResult(  OperationContext.ResultAction resultAction,  OperationContext context,  ModelNode operation){
    ControllerLogger.MGMT_OP_LOGGER.tracef("ModelAddressResolver response from remote process is %s",resultItem);
    if (filtered.get()) {
      ControllerLogger.MGMT_OP_LOGGER.trace("Response was filtered");
      return;
    }
    PathAddress rbacPrefix=base.size() > 1 && base.getElement(1).getKey().equals(RUNNING_SERVER) ? base : PathAddress.EMPTY_ADDRESS;
    if (remaining.isMultiTarget()) {
      if (resultItem.has(RESULT) && resultItem.get(RESULT).getType() == ModelType.LIST) {
        for (        final ModelNode rr : resultItem.get(RESULT).asList()) {
          final ModelNode nr=result.add();
          final PathAddress address=PathAddress.pathAddress(rr.get(OP_ADDR));
          int max=Math.min(base.size(),address.size());
          int match=0;
          for (int i=0; i < max; i++) {
            final PathElement eb=base.getElement(i);
            final PathElement ea=address.getElement(i);
            if (eb.getKey().equals(ea.getKey())) {
              match=i + 1;
            }
          }
          final PathAddress resolvedAddress=base.append(address.subAddress(match));
          ControllerLogger.MGMT_OP_LOGGER.tracef("recording multi-target ModelAddressResolver response " + "to %s at %s",fullAddress,resolvedAddress);
          nr.get(OP_ADDR).set(resolvedAddress.toModelNode());
          nr.get(OUTCOME).set(rr.get(OUTCOME));
          nr.get(RESULT).set(rr.get(RESULT));
          if (rr.hasDefined(RESPONSE_HEADERS)) {
            ModelNode headers=rr.get(RESPONSE_HEADERS);
            ModelNode acc=headers.remove(ACCESS_CONTROL);
            if (headers.asInt() > 0) {
              nr.get(RESPONSE_HEADERS).set(headers);
            }
            if (acc != null && acc.isDefined()) {
              filteredData.populate(acc,rbacPrefix);
              ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,rr);
            }
          }
        }
        if (resultItem.hasDefined(RESPONSE_HEADERS,ACCESS_CONTROL)) {
          ModelNode acc=resultItem.get(RESPONSE_HEADERS,ACCESS_CONTROL);
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
        }
      }
    }
 else {
      ControllerLogger.MGMT_OP_LOGGER.tracef("recording non-multi-target ModelAddressResolver response " + "to %s",fullAddress);
      final ModelNode nr=result.add();
      nr.get(OP_ADDR).set(fullAddress.toModelNode());
      nr.get(OUTCOME).set(resultItem.get(OUTCOME));
      nr.get(RESULT).set(resultItem.get(RESULT));
      if (resultItem.hasDefined(RESPONSE_HEADERS)) {
        ModelNode headers=resultItem.get(RESPONSE_HEADERS);
        ModelNode acc=headers.remove(ACCESS_CONTROL);
        if (headers.asInt() > 0) {
          nr.get(RESPONSE_HEADERS).set(headers);
        }
        if (acc != null && acc.isDefined()) {
          filteredData.populate(acc,PathAddress.EMPTY_ADDRESS);
          ControllerLogger.MGMT_OP_LOGGER.tracef("Populated local filtered data " + "with remote access control headers %s from result item %s",acc,resultItem);
        }
      }
    }
  }
}
] @AT@ 38640 @LENGTH@ 6143

