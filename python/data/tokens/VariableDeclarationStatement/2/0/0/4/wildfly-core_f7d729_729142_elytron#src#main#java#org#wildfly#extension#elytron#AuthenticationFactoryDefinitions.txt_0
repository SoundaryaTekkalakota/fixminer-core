UPD VariableDeclarationStatement@@AbstractAddStepHandler add=new TrivialAddHandler<HttpAuthenticationFactory>(HttpAuthenticationFactory.class,attributes,HTTP_AUTHENTICATION_FACTORY_RUNTIME_CAPABILITY){
  @Override protected ValueSupplier<HttpAuthenticationFactory> getValueSupplier(  ServiceBuilder<HttpAuthenticationFactory> serviceBuilder,  OperationContext context,  ModelNode model) throws OperationFailedException {
    final InjectedValue<SecurityDomain> securityDomainInjector=new InjectedValue<SecurityDomain>();
    final InjectedValue<HttpServerAuthenticationMechanismFactory> mechanismFactoryInjector=new InjectedValue<HttpServerAuthenticationMechanismFactory>();
    String securityDomain=securityDomainAttribute.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(SECURITY_DOMAIN_CAPABILITY,securityDomain),SecurityDomain.class),SecurityDomain.class,securityDomainInjector);
    String httpServerFactory=HTTP_SERVER_MECHANISM_FACTORY.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(HTTP_SERVER_MECHANISM_FACTORY_CAPABILITY,httpServerFactory),HttpServerAuthenticationMechanismFactory.class),HttpServerAuthenticationMechanismFactory.class,mechanismFactoryInjector);
    final Set<String> supportedMechanisms=getConfiguredMechanismNames(mechanismConfigurationAttribute,context,model);
    final List<ResolvedMechanismConfiguration> resolvedMechanismConfigurations=getResolvedMechanismConfiguration(mechanismConfigurationAttribute,serviceBuilder,context,model);
    return () -> {
      HttpServerAuthenticationMechanismFactory serverFactory=mechanismFactoryInjector.getValue();
      if (!supportedMechanisms.isEmpty()) {
        serverFactory=new FilterServerMechanismFactory(serverFactory,true,supportedMechanisms);
      }
      HttpAuthenticationFactory.Builder builder=HttpAuthenticationFactory.builder().setSecurityDomain(securityDomainInjector.getValue()).setFactory(serverFactory);
      buildMechanismConfiguration(resolvedMechanismConfigurations,builder);
      return builder.build();
    }
;
  }
}
; @TO@ AbstractAddStepHandler add=new TrivialAddHandler<HttpAuthenticationFactory>(HttpAuthenticationFactory.class,attributes,HTTP_AUTHENTICATION_FACTORY_RUNTIME_CAPABILITY){
  @Override protected ValueSupplier<HttpAuthenticationFactory> getValueSupplier(  ServiceBuilder<HttpAuthenticationFactory> serviceBuilder,  OperationContext context,  ModelNode model) throws OperationFailedException {
    final InjectedValue<SecurityDomain> securityDomainInjector=new InjectedValue<SecurityDomain>();
    final InjectedValue<HttpServerAuthenticationMechanismFactory> mechanismFactoryInjector=new InjectedValue<HttpServerAuthenticationMechanismFactory>();
    String securityDomain=securityDomainAttribute.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(SECURITY_DOMAIN_CAPABILITY,securityDomain),SecurityDomain.class),SecurityDomain.class,securityDomainInjector);
    String httpServerFactory=HTTP_SERVER_MECHANISM_FACTORY.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(HTTP_SERVER_MECHANISM_FACTORY_CAPABILITY,httpServerFactory),HttpServerAuthenticationMechanismFactory.class),HttpServerAuthenticationMechanismFactory.class,mechanismFactoryInjector);
    final Set<String> supportedMechanisms=getConfiguredMechanismNames(mechanismConfigurationAttribute,context,model);
    final List<ResolvedMechanismConfiguration> resolvedMechanismConfigurations=getResolvedMechanismConfiguration(mechanismConfigurationAttribute,serviceBuilder,context,model);
    return () -> {
      HttpServerAuthenticationMechanismFactory serverFactory=mechanismFactoryInjector.getValue();
      if (!supportedMechanisms.isEmpty()) {
        serverFactory=new FilterServerMechanismFactory(serverFactory,true,supportedMechanisms);
        final String[] mechanisms=supportedMechanisms.toArray(new String[supportedMechanisms.size()]);
        serverFactory=new SortedServerMechanismFactory(serverFactory,(a,b) -> {
          for (          String definedMech : mechanisms) {
            if (a.equals(definedMech)) {
              return -1;
            }
 else             if (b.equals(definedMech)) {
              return 1;
            }
          }
          return 0;
        }
);
      }
 else {
        serverFactory=new SortedServerMechanismFactory(serverFactory,AuthenticationFactoryDefinitions::compareHttp);
      }
      HttpAuthenticationFactory.Builder builder=HttpAuthenticationFactory.builder().setSecurityDomain(securityDomainInjector.getValue()).setFactory(serverFactory);
      buildMechanismConfiguration(resolvedMechanismConfigurations,builder);
      return builder.build();
    }
;
  }
}
; @AT@ 23650 @LENGTH@ 2778
---UPD VariableDeclarationFragment@@add=new TrivialAddHandler<HttpAuthenticationFactory>(HttpAuthenticationFactory.class,attributes,HTTP_AUTHENTICATION_FACTORY_RUNTIME_CAPABILITY){
  @Override protected ValueSupplier<HttpAuthenticationFactory> getValueSupplier(  ServiceBuilder<HttpAuthenticationFactory> serviceBuilder,  OperationContext context,  ModelNode model) throws OperationFailedException {
    final InjectedValue<SecurityDomain> securityDomainInjector=new InjectedValue<SecurityDomain>();
    final InjectedValue<HttpServerAuthenticationMechanismFactory> mechanismFactoryInjector=new InjectedValue<HttpServerAuthenticationMechanismFactory>();
    String securityDomain=securityDomainAttribute.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(SECURITY_DOMAIN_CAPABILITY,securityDomain),SecurityDomain.class),SecurityDomain.class,securityDomainInjector);
    String httpServerFactory=HTTP_SERVER_MECHANISM_FACTORY.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(HTTP_SERVER_MECHANISM_FACTORY_CAPABILITY,httpServerFactory),HttpServerAuthenticationMechanismFactory.class),HttpServerAuthenticationMechanismFactory.class,mechanismFactoryInjector);
    final Set<String> supportedMechanisms=getConfiguredMechanismNames(mechanismConfigurationAttribute,context,model);
    final List<ResolvedMechanismConfiguration> resolvedMechanismConfigurations=getResolvedMechanismConfiguration(mechanismConfigurationAttribute,serviceBuilder,context,model);
    return () -> {
      HttpServerAuthenticationMechanismFactory serverFactory=mechanismFactoryInjector.getValue();
      if (!supportedMechanisms.isEmpty()) {
        serverFactory=new FilterServerMechanismFactory(serverFactory,true,supportedMechanisms);
      }
      HttpAuthenticationFactory.Builder builder=HttpAuthenticationFactory.builder().setSecurityDomain(securityDomainInjector.getValue()).setFactory(serverFactory);
      buildMechanismConfiguration(resolvedMechanismConfigurations,builder);
      return builder.build();
    }
;
  }
}
 @TO@ add=new TrivialAddHandler<HttpAuthenticationFactory>(HttpAuthenticationFactory.class,attributes,HTTP_AUTHENTICATION_FACTORY_RUNTIME_CAPABILITY){
  @Override protected ValueSupplier<HttpAuthenticationFactory> getValueSupplier(  ServiceBuilder<HttpAuthenticationFactory> serviceBuilder,  OperationContext context,  ModelNode model) throws OperationFailedException {
    final InjectedValue<SecurityDomain> securityDomainInjector=new InjectedValue<SecurityDomain>();
    final InjectedValue<HttpServerAuthenticationMechanismFactory> mechanismFactoryInjector=new InjectedValue<HttpServerAuthenticationMechanismFactory>();
    String securityDomain=securityDomainAttribute.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(SECURITY_DOMAIN_CAPABILITY,securityDomain),SecurityDomain.class),SecurityDomain.class,securityDomainInjector);
    String httpServerFactory=HTTP_SERVER_MECHANISM_FACTORY.resolveModelAttribute(context,model).asString();
    serviceBuilder.addDependency(context.getCapabilityServiceName(buildDynamicCapabilityName(HTTP_SERVER_MECHANISM_FACTORY_CAPABILITY,httpServerFactory),HttpServerAuthenticationMechanismFactory.class),HttpServerAuthenticationMechanismFactory.class,mechanismFactoryInjector);
    final Set<String> supportedMechanisms=getConfiguredMechanismNames(mechanismConfigurationAttribute,context,model);
    final List<ResolvedMechanismConfiguration> resolvedMechanismConfigurations=getResolvedMechanismConfiguration(mechanismConfigurationAttribute,serviceBuilder,context,model);
    return () -> {
      HttpServerAuthenticationMechanismFactory serverFactory=mechanismFactoryInjector.getValue();
      if (!supportedMechanisms.isEmpty()) {
        serverFactory=new FilterServerMechanismFactory(serverFactory,true,supportedMechanisms);
        final String[] mechanisms=supportedMechanisms.toArray(new String[supportedMechanisms.size()]);
        serverFactory=new SortedServerMechanismFactory(serverFactory,(a,b) -> {
          for (          String definedMech : mechanisms) {
            if (a.equals(definedMech)) {
              return -1;
            }
 else             if (b.equals(definedMech)) {
              return 1;
            }
          }
          return 0;
        }
);
      }
 else {
        serverFactory=new SortedServerMechanismFactory(serverFactory,AuthenticationFactoryDefinitions::compareHttp);
      }
      HttpAuthenticationFactory.Builder builder=HttpAuthenticationFactory.builder().setSecurityDomain(securityDomainInjector.getValue()).setFactory(serverFactory);
      buildMechanismConfiguration(resolvedMechanismConfigurations,builder);
      return builder.build();
    }
;
  }
}
 @AT@ 23673 @LENGTH@ 2754

