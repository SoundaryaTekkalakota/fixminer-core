UPD VariableDeclarationStatement@@boolean sync=producerCache.doInAsyncProducer(endpoint,exchange,null,callback,new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=exchange;
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          Exchange copy=prepareExchangeForRoutingSlip(current,endpoint);
          boolean sync=processExchange(endpoint,copy,original,callback,iter);
          current=copy;
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
); @TO@ boolean sync=producerCache.doInAsyncProducer(endpoint,exchange,null,callback,new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=prepareExchangeForRoutingSlip(exchange,endpoint);
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          boolean sync=processExchange(endpoint,current,original,callback,iter);
          current=prepareExchangeForRoutingSlip(current,endpoint);
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
); @AT@ 11210 @LENGTH@ 4171
---UPD VariableDeclarationFragment@@sync=producerCache.doInAsyncProducer(endpoint,exchange,null,callback,new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=exchange;
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          Exchange copy=prepareExchangeForRoutingSlip(current,endpoint);
          boolean sync=processExchange(endpoint,copy,original,callback,iter);
          current=copy;
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
) @TO@ sync=producerCache.doInAsyncProducer(endpoint,exchange,null,callback,new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=prepareExchangeForRoutingSlip(exchange,endpoint);
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          boolean sync=processExchange(endpoint,current,original,callback,iter);
          current=prepareExchangeForRoutingSlip(current,endpoint);
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
) @AT@ 11218 @LENGTH@ 4162
------UPD MethodInvocation@@producerCache.doInAsyncProducer(endpoint,exchange,null,callback,new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=exchange;
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          Exchange copy=prepareExchangeForRoutingSlip(current,endpoint);
          boolean sync=processExchange(endpoint,copy,original,callback,iter);
          current=copy;
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
) @TO@ producerCache.doInAsyncProducer(endpoint,exchange,null,callback,new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=prepareExchangeForRoutingSlip(exchange,endpoint);
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          boolean sync=processExchange(endpoint,current,original,callback,iter);
          current=prepareExchangeForRoutingSlip(current,endpoint);
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
) @AT@ 11225 @LENGTH@ 4155
---------UPD SimpleName@@MethodName:doInAsyncProducer:[endpoint, exchange, null, callback, new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=exchange;
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          Exchange copy=prepareExchangeForRoutingSlip(current,endpoint);
          boolean sync=processExchange(endpoint,copy,original,callback,iter);
          current=copy;
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
] @TO@ MethodName:doInAsyncProducer:[endpoint, exchange, null, callback, new AsyncProducerCallback(){
  public boolean doInAsyncProducer(  Producer producer,  AsyncProcessor asyncProducer,  final Exchange exchange,  ExchangePattern exchangePattern,  final AsyncCallback callback){
    exchange.setProperty(Exchange.TO_ENDPOINT,endpoint.getEndpointUri());
    exchange.setProperty(Exchange.SLIP_ENDPOINT,endpoint.getEndpointUri());
    return asyncProducer.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        if (doneSync) {
          callback.done(doneSync);
          return;
        }
        Exchange current=prepareExchangeForRoutingSlip(exchange,endpoint);
        while (iter.hasNext(current)) {
          if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e=current.getException(FailedToCreateProducerException.class);
            if (e != null) {
              if (log.isDebugEnabled()) {
                log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.",e);
              }
              current.setException(null);
            }
          }
          if (!continueProcessing(current,"so breaking out of the routing slip",log)) {
            break;
          }
          Endpoint endpoint;
          try {
            endpoint=resolveEndpoint(iter,exchange);
            if (endpoint == null) {
              continue;
            }
          }
 catch (          Exception e) {
            exchange.setException(e);
            break;
          }
          boolean sync=processExchange(endpoint,current,original,callback,iter);
          current=prepareExchangeForRoutingSlip(current,endpoint);
          if (!sync) {
            log.trace("Processing exchangeId: {} is continued being processed asynchronously",original.getExchangeId());
            return;
          }
        }
        log.trace("Processing complete for exchangeId: {} >>> {}",original.getExchangeId(),current);
        ExchangeHelper.copyResults(original,current);
        callback.done(false);
      }
    }
);
  }
}
] @AT@ 11239 @LENGTH@ 4141

